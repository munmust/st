内存生命周期基本是一致的：
-   分配你所需要的内存
-   使用分配到的内存（读、写）
-   不需要时将其释放\归还
当我们创建变量（对象，字符串等）的时候，系统会自动给对象分配对应的内存。
当系统发现这些变量不再被使用的时候，会自动释放（垃圾回收）这些变量的内存，开发者不用过多的关心内存问题
数据类型分为两类，简单类型和引用类型，对于简单类型，内存是保存在栈（stack）空间中，复杂数据类型，内存是保存在堆（heap）空间中
-   基本类型：这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的
-   引用类型：引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的
对于栈的内存空间，只保存简单数据类型的内存，由操作系统自动分配和自动释放。而堆空间中的内存，由于大小不固定，系统无法无法进行自动释放，这个时候就需要JS引擎来手动的释放这些内存

####	V8 将堆分为两类新生代和老生代，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象
-	副垃圾回收器 - Scavenge：主要负责新生代的垃圾回收。
-	主垃圾回收器 - Mark-Sweep & Mark-Compact：主要负责老生代的垃圾回收。

###	活动对象及非活动对象
	从根对象（indow，global）的指针开始，这个指针称为根集，从这个根集向下搜索其子节点，被搜索到的字节点说明改子节点的引用对象可达，并留下标记，然后递归这个搜索的过程，直到所有的子节点都被遍历结束，那么没有遍历到的对象节点，说明该对象没有被引用，是一个需要被释放内存的对象，可以被回收。
###	新生代晋升老生代
	新生代中有nursery和intermediate子代两个区域，一个对象第一次分配进入nursery中，如果经过下一次垃圾回收这个对象还在新生代中，将他移到intermediate中，再经过一次垃圾回收，还在新生代中就将对象移到老生代中，称为晋升。
### Scavenge :
	牺牲空间换取时间的复制算法
	任何对象的声明分配到的内存，将会先被放置在新生代中
	将新生代堆分为两部分，分别叫from-space和to-space，将from-space中存活的活动对象复制到to-space中，并将这些对象的内存有序的排列起来，然后将from-space中的非活动对象的内存进行释放，完成之后，将from space 和to space进行互换，这样可以使得新生代中的这两块区域可以重复利用
-	标记活动对象和非活动对象
-	复制from space的活动对象到to space并对其进行排序
-	释放form space中的非活动对象
-	将form space和to space角色互换
###	Mark-Sweep&Mark-Compact
####	Mark-Sweep

分为两个阶段
-	标记阶段：对老生代进行一次扫描，标记活动对象
Scavenge算法是复制活动对象，标记了活动对象和非活动对象之后，直接把非活动对象清除
（被清除的对象遍布于各内存地址，产生很多内存碎片）
-	清除阶段：对老生代进行二次扫描，清楚未被标记的对象（清楚非活动对象）
在 Mark-Sweep的基础上演进而来的，相比Mark-Sweep，Mark-Compact添加了活动对象整理阶段，将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存
####	stop-the-world
全停顿
	Mark-compact执行过程中会移动对象，当对象较多的时候执行速度出现问题，为了避免js应用逻辑和垃圾回收器内存资源竞争导致的不一致问题，垃圾回收器会暂停应用（全停顿）。当对象过多的时候主动暂停主线程时间较长，使页面变得卡顿。
##	Orinoco
####	增量标记 Incremental marking
	为了降低全堆垃圾回收带来的停顿时间，V8在标记时采用增量标记（incremental marking），即将标记拆分为许多小步进，每一个步进完成时，就让js逻辑执行一小会。垃圾回收和逻辑执行交替进行，直到标记阶段完成。
####	懒性清理 Lazy sweeping
	当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性清理完所有非活动对象内存，垃圾回收器会按需逐一进行清理，直到所有的页都清理完毕
由于每个小的增量标记之间执行了JavaScript代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化
-	并没有减少主线程的总暂停的时间，甚至会略微增加
-	由于写屏障（Write-barrier）机制的成本，增量标记可能会降低应用程序的吞吐量
####	并发
	在垃圾回收的同时不需要将主线程挂起，两者可以同时进行，只有在个别时候需要短暂停下来让垃圾回收器做一些特殊的操作。但是这种方式也要面对增量回收的问题，就是在垃圾回收过程中，由于JavaScript代码在执行，堆中的对象的引用关系随时可能会变化，所以也要进行写屏障操作
####	并行
	并行式GC允许主线程和辅助线程同时执行同样的GC工作，这样可以让辅助线程来分担主线程的GC工作，使得垃圾回收所耗费的时间等于总时间除以参与的线程数量（加上一些同步开销）。